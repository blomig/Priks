<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Priks V2</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        #gameContainer {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        #info {
            margin-top: 10px;
        }
        #rules {
            font-size: 0.9em; /* Police légèrement plus petite */
            margin-top: 5px;
            max-width: 600px; /* Limite la largeur pour la lisibilité */
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="320" height="400"></canvas>
        <div id="info">
            <p>Bombes restantes : <span id="bombCount">1</span></p>
            <p>Score : <span id="score">0</span></p>
            <p>Coups joués : <span id="moveCount">0</span></p>
            <p>Utilisez ← et → pour déplacer, Espace pour placer, B pour sélectionner une bombe</p>
            <p id="rules">Le but de Priks est de faire le plus gros score en faisant des chaînes de 5 blox de même couleur. La difficulté ? Régulièrement, des blox gris arrivent (des Priks) qui ne peuvent pas être cassés. Et tous les 10 tours, une floppée de blox vient mettre le bazar. Heureusement, vous disposez de bombes (1 au début, puis 1 supplémentaire toutes les 5 chaînes) qui cassent tout ce qu'elles touchent - y compris les Priks ! À vous de jouer !</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const gridSize = 8;
        const cellSize = canvas.width / gridSize;
        const previewHeight = cellSize * 2;
        let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
        let bombCount = 1;
        let chainCount = 0;
        let score = 0;
        let moveCount = 0;
        let nextBlock = null;
        let blockPosition = 0;
        let nextLine = null;
        let isBombSelected = false;

        const colors = ["red", "blue", "green", "yellow", "purple", "orange"];
        const priksColor = "gray";
        const bombColor = "black";

        // Générer un nouveau Blox
        function getNewBlock() {
            if (Math.random() < 0.1) return priksColor;
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Générer une nouvelle ligne de 8 Blox
        function getNewLine() {
            let newLine = Array(gridSize);
            for (let i = 0; i < gridSize; i++) {
                newLine[i] = colors[Math.floor(Math.random() * colors.length)];
            }
            let priksCol = Math.floor(Math.random() * gridSize);
            newLine[priksCol] = priksColor;
            return newLine;
        }

        if (!nextBlock) nextBlock = getNewBlock();
        if (!nextLine) nextLine = getNewLine();

        // Dessiner la grille, le prochain Blox ou la bombe, et la prochaine ligne
        function drawGrid(movingBlocks = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    if (grid[row][col]) {
                        ctx.fillStyle = grid[row][col];
                        ctx.fillRect(col * cellSize + 2, row * cellSize + 2, cellSize - 4, cellSize - 4);
                    }
                }
            }
            ctx.strokeRect(0, gridSize * cellSize, canvas.width, previewHeight);
            ctx.fillStyle = isBombSelected ? bombColor : nextBlock;
            ctx.fillRect(blockPosition * cellSize + 2, gridSize * cellSize + 2, cellSize - 4, cellSize - 4);
            if (moveCount % 10 === 9) {
                for (let col = 0; col < gridSize; col++) {
                    ctx.fillStyle = nextLine[col];
                    ctx.fillRect(col * cellSize + 2, (gridSize + 1) * cellSize + 2, cellSize - 4, cellSize - 4);
                }
            }
            movingBlocks.forEach(({ x, y, color }) => {
                ctx.fillStyle = color;
                ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
            });
        }

        // Animation pour un Blox ou une bombe jouée
        async function animateBlock(col, startY, endRow, isBomb = false) {
            const startRow = gridSize;
            const endY = endRow * cellSize;
            const duration = 100;
            const steps = 10;
            const stepDuration = duration / steps;
            const stepDistance = (startY - endY) / steps;

            let currentY = startY;
            const color = isBomb ? bombColor : nextBlock;
            for (let i = 0; i <= steps; i++) {
                drawGrid([{ x: col * cellSize, y: currentY, color }]);
                currentY -= stepDistance;
                await new Promise(resolve => setTimeout(resolve, stepDuration));
            }
        }

        // Animation pour la gravité inversée
        async function animateGravity(movingBlocks) {
            const duration = 100;
            const steps = 10;
            const stepDuration = duration / steps;
            const animatedBlocks = movingBlocks.map(({ startRow, endRow, col, color }) => ({
                x: col * cellSize,
                y: startRow * cellSize,
                targetY: endRow * cellSize,
                color,
                stepDistance: (startRow * cellSize - endRow * cellSize) / steps
            }));

            for (let i = 0; i <= steps; i++) {
                animatedBlocks.forEach(block => {
                    block.y -= block.stepDistance;
                });
                drawGrid(animatedBlocks);
                await new Promise(resolve => setTimeout(resolve, stepDuration));
            }
        }

        // Ajouter un Blox ou une bombe dans une colonne avec animation
        async function addBlock(col) {
            let row = gridSize - 1;
            while (row >= 0 && !grid[row][col]) row--;
            row++;
            if (row >= gridSize) {
                endGame();
                return;
            }
            if (isBombSelected) {
                await animateBlock(col, gridSize * cellSize, row, true);
                let toRemove = [];
                for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
                        if (grid[r][c]) {
                            toRemove.push([r, c]);
                        }
                    }
                }
                if (toRemove.length > 0) {
                    await blinkBlocks(toRemove);
                }
                for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
                        grid[r][c] = null;
                    }
                }
                bombCount--;
                isBombSelected = false;
                await animateGravity(calculateGravityMoves());
                await checkChains();
            } else {
                await animateBlock(col, gridSize * cellSize, row);
                grid[row][col] = nextBlock;
                moveCount++;
                nextBlock = getNewBlock();
                await checkChains();
                if (moveCount % 10 === 0 && moveCount > 0) {
                    addRandomLine();
                    nextLine = getNewLine();
                }
            }
            drawGrid();
            updateUI();
        }

        // Ajouter la ligne complète avec 1 Priks
        function addRandomLine() {
            for (let col = 0; col < gridSize; col++) {
                let row = gridSize - 1;
                while (row >= 0 && !grid[row][col]) row--;
                row++;
                if (row >= gridSize) {
                    endGame();
                    return;
                }
                grid[row][col] = nextLine[col];
            }
            drawGrid();
            checkChains();
        }

        // Faire clignoter les Blox avant suppression
        async function blinkBlocks(blocks) {
            const blinkCount = 3;
            const blinkDuration = 150;

            for (let i = 0; i < blinkCount; i++) {
                blocks.forEach(([row, col]) => {
                    ctx.clearRect(col * cellSize + 2, row * cellSize + 2, cellSize - 4, cellSize - 4);
                    ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
                });
                await new Promise(resolve => setTimeout(resolve, blinkDuration));
                drawGrid();
                await new Promise(resolve => setTimeout(resolve, blinkDuration));
            }
        }

        // Vérifier et supprimer les chaînes de 5 ou plus en cascade
        async function checkChains() {
            let chainsRemoved;
            let isGravityChain = false;
            do {
                chainsRemoved = false;
                let visited = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
                let toRemove = [];

                function dfs(row, col, color, group) {
                    if (row < 0 || row >= gridSize || col < 0 || col >= gridSize || visited[row][col] || grid[row][col] !== color) {
                        return;
                    }
                    visited[row][col] = true;
                    group.push([row, col]);
                    dfs(row - 1, col, color, group);
                    dfs(row + 1, col, color, group);
                    dfs(row, col - 1, color, group);
                    dfs(row, col + 1, color, group);
                    dfs(row - 1, col - 1, color, group);
                    dfs(row - 1, col + 1, color, group);
                    dfs(row + 1, col - 1, color, group);
                    dfs(row + 1, col + 1, color, group);
                }

                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (grid[row][col] && grid[row][col] !== priksColor && !visited[row][col]) {
                            let group = [];
                            dfs(row, col, grid[row][col], group);
                            if (group.length >= 5) {
                                toRemove = toRemove.concat(group);
                                if (isGravityChain) {
                                    score += 10;
                                } else if (group.length > 5) {
                                    score += 10;
                                } else {
                                    score += 5;
                                }
                            }
                        }
                    }
                }

                if (toRemove.length > 0) {
                    chainsRemoved = true;
                    await blinkBlocks(toRemove);
                    toRemove.forEach(([row, col]) => {
                        grid[row][col] = null;
                    });
                    chainCount++;
                    if (chainCount % 5 === 0) bombCount++;
                    isGravityChain = true;
                    await animateGravity(calculateGravityMoves());
                    drawGrid();
                } else {
                    isGravityChain = false;
                }
            } while (chainsRemoved);
        }

        // Calculer les mouvements de gravité pour l’animation
        function calculateGravityMoves() {
            let moves = [];
            for (let col = 0; col < gridSize; col++) {
                let newCol = [];
                for (let row = 0; row < gridSize; row++) {
                    if (grid[row][col]) newCol.push({ row, color: grid[row][col] });
                }
                for (let i = 0; i < newCol.length; i++) {
                    let startRow = newCol[i].row;
                    let endRow = i;
                    if (startRow !== endRow) {
                        moves.push({ startRow, endRow, col, color: newCol[i].color });
                    }
                }
                for (let row = 0; row < gridSize; row++) {
                    grid[row][col] = (row < newCol.length) ? newCol[row].color : null;
                }
            }
            return moves;
        }

        // Mettre à jour l'interface
        function updateUI() {
            document.getElementById("bombCount").textContent = bombCount;
            document.getElementById("score").textContent = score;
            document.getElementById("moveCount").textContent = moveCount;
        }

        // Fin du jeu
        function endGame() {
            alert("Jeu terminé ! Score final : " + score);
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            bombCount = 1;
            chainCount = 0;
            score = 0;
            moveCount = 0;
            nextBlock = getNewBlock();
            nextLine = getNewLine();
            isBombSelected = false;
            blockPosition = 0;
            drawGrid();
            updateUI();
        }

        // Gestion des touches du clavier
        document.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "ArrowLeft":
                    if (blockPosition > 0) blockPosition--;
                    drawGrid();
                    break;
                case "ArrowRight":
                    if (blockPosition < gridSize - 1) blockPosition++;
                    drawGrid();
                    break;
                case " ":
                    event.preventDefault();
                    addBlock(blockPosition);
                    break;
                case "b":
                case "B":
                    if (bombCount > 0 && !isBombSelected) {
                        isBombSelected = true;
                        drawGrid();
                    }
                    break;
            }
        });

        drawGrid();
        updateUI();
    </script>
</body>
</html>
