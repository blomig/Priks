<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Pour mobile -->
    <title>Priks V3</title>
   
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        #gameContainer {
            text-align: center;
            font-family: Arial, sans-serif;
            position: relative;
        }
        #info {
            margin-top: 10px;
        }
        #rules {
            font-size: 0.9em;
            margin-top: 5px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #underGrid {
            display: flex;
            justify-content: space-between;
            width: 320px;
            margin: 5px auto 0;
        }
        #progressContainer {
    width: 100px; /* Largeur fixe de la barre */
    height: 10px;
    background-color: #e0e0e0; /* Fond gris clair */
    border: 1px solid #000;
    position: relative;
    margin: 5px 0;
}
#progressBar {
    height: 100%;
    width: 0%; /* Commence vide */
    background-color: #4caf50; /* Vert par défaut */
    transition: width 0.2s ease-in-out; /* Animation fluide */
}
        #scoreDisplay {
            font-size: 1.5em;
        }
        #bombDisplay {
            display: flex;
            align-items: center;
            flex-direction: column;
        }
        #bombDisplay img {
            width: 36px;
            height: 36px;
            margin-right: 5px;
            cursor: pointer; /* Indique que c’est cliquable */
        }
        #bombCount {
            font-size: 1.5em;
        }
        #chainsRemaining {
            font-size: 0.8em;
            margin-top: 2px;
        }
        #highScores {
            position: absolute;
            right: calc(50% - 400px);
            top: 0;
            width: 150px;
            text-align: left;
            font-size: 0.9em;
        }
        #highScores h3 {
            margin: 0 0 5px 0;
        }
        #highScores ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
         @font-face {
    font-family: "gameboy"; /* Nom que tu choisis pour l’utiliser */
    src: url("gameboy.ttf") format("truetype"); /* Chemin vers le fichier */
    }
    </style>
</head>
<body>
    <div id="gameContainer">
        <audio id="placeSound" src="place.wav" preload="auto"></audio>
<audio id="chainSound" src="chain.mp3" preload="auto"></audio>
<audio id="bombSound" src="bomb.wav" preload="auto"></audio>
        <canvas id="gameCanvas" width="360" height="400"></canvas>
        <div id="highScores">
            <h3>Meilleurs Scores</h3>
            <ul id="highScoreList"></ul>
        </div>
         <div id="underGrid">
            
          <div id="scoreDisplay">Score : <span id="score">0</span></div>
         <!-- Nouvelle barre de progression -->
           <div id="progressContainer">
             <div id="progressBar"></div>
           </div>
        <div id="bombDisplay">
        <div style="display: flex; align-items: center;">
            <img src="bomb.png" alt="Bombes" id="bombIcon">
            <span id="bombCount">1</span>
        </div>
        <span id="chainsRemaining">Chaînes restantes : 10</span>
    </div>
</div>
            
        </div>
        <div id="info">
            <p>Utilisez ← et → (ou cliquez/touchez une colonne) pour déplacer, Espace (ou clic colonne) pour placer, B (ou clic bombe) pour sélectionner une bombe</p>
            <p id="rules">Le but de Priks est de faire le plus gros score en faisant des chaînes de 5 blox de même couleur. La difficulté ? Régulièrement, des blox gris arrivent (des Priks) qui ne peuvent pas être cassés sauf par bombes ou chaînes adjacentes (5→4→3→2→1→disparition). Et tous les 10 tours, une floppée de blox vient mettre le bazar. Heureusement, vous disposez de bombes (1 au début, puis 1 supplémentaire toutes les 10 chaînes) qui cassent tout ce qu'elles touchent - y compris les Priks ! À vous de jouer !</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const gridSize = 8;
        const cellSize = 320 / gridSize;
        const previewHeight = cellSize * 2;
        let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
        let bombCount = 1;
        let chainCount = 0;
        let score = 0;
        let moveCount = 0;
        let nextBlock = null;
        let nextNextBlock = null;
        let blockPosition = 0;
        let nextLine = null;
        let isBombSelected = false;

        const colors = ["red", "blue", "green", "yellow", "purple", "orange"];
        const priksColor = "gray";
        const bombColor = "bomb";

        // Charger les images
        const images = {};
        colors.forEach(color => {
            images[color] = new Image();
            images[color].src = `${color}.png`;
        });
        images[priksColor] = new Image();
        images[priksColor].src = "priks.png";
        images[bombColor] = new Image();
        images[bombColor].src = "bomb.png";

        // Générer un nouveau Blox
        function getNewBlock() {
            if (Math.random() < 0.1) return [priksColor, 5];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Générer une nouvelle ligne de 8 Blox
        function getNewLine() {
            let newLine = Array(gridSize);
            for (let i = 0; i < gridSize; i++) {
                newLine[i] = colors[Math.floor(Math.random() * colors.length)];
            }
            let priksCol = Math.floor(Math.random() * gridSize);
            newLine[priksCol] = [priksColor, 5];
            return newLine;
        }

        if (!nextBlock) nextBlock = getNewBlock();
        if (!nextNextBlock) nextNextBlock = getNewBlock();
        if (!nextLine) nextLine = getNewLine();

        // Charger et afficher les hiscores
        function loadHighScores() {
            const highScores = JSON.parse(localStorage.getItem("priksHighScores")) || [];
            return highScores.length ? highScores : [["AAAAA", 0], ["BBBBB", 0], ["CCCCC", 0], ["DDDDD", 0], ["EEEEE", 0], ["FFFFF", 0], ["GGGGG", 0], ["HHHHH", 0], ["IIIII", 0], ["JJJJJ", 0]];
        }

        function saveHighScores(highScores) {
            localStorage.setItem("priksHighScores", JSON.stringify(highScores));
        }

        function updateHighScoresDisplay() {
            const highScores = loadHighScores();
            const list = document.getElementById("highScoreList");
            list.innerHTML = "";
            highScores.forEach(([name, score]) => {
                const li = document.createElement("li");
                li.textContent = `${name} : ${score}`;
                list.appendChild(li);
            });
        }

        function addHighScore(score) {
            let highScores = loadHighScores();
            let name = prompt("Nouveau highscore ! Entrez vos initiales (5 lettres max) :", "AAAAA");
            if (name) {
                name = name.slice(0, 5).padEnd(5, " ").toUpperCase();
                highScores.push([name, score]);
                highScores.sort((a, b) => b[1] - a[1]);
                highScores = highScores.slice(0, 10);
                saveHighScores(highScores);
                updateHighScoresDisplay();
            }
        }

        // Dessiner la grille avec images et compteurs pour les Priks
        function drawGrid(movingBlocks = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    ctx.strokeRect(col * cellSize + 40, row * cellSize, cellSize, cellSize);
                    if (grid[row][col]) {
                        const block = grid[row][col];
                        const color = Array.isArray(block) ? block[0] : block;
                        if (images[color] && images[color].complete) {
                            ctx.drawImage(images[color], col * cellSize + 40 + 2, row * cellSize + 2, cellSize - 4, cellSize - 4);
                            if (Array.isArray(block) && block[0] === priksColor) {
                                ctx.fillStyle = "white";
                                ctx.font = "16px gameboy";
                                ctx.textAlign = "center";
                                ctx.textBaseline = "middle";
                                ctx.fillText(block[1], col * cellSize + 40 + cellSize / 2, row * cellSize + cellSize / 2);
                            }
                        }
                    }
                }
            }
            ctx.strokeRect(40, gridSize * cellSize, 320, previewHeight);
            const previewBlock = isBombSelected ? bombColor : nextBlock;
            const previewColor = Array.isArray(previewBlock) ? previewBlock[0] : previewBlock;
            if (images[previewColor] && images[previewColor].complete) {
                ctx.drawImage(images[previewColor], blockPosition * cellSize + 40 + 2, gridSize * cellSize + 2, cellSize - 4, cellSize - 4);
                if (Array.isArray(previewBlock) && previewBlock[0] === priksColor) {
                    ctx.fillStyle = "white";
                    ctx.font = "16px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(previewBlock[1], blockPosition * cellSize + 40 + cellSize / 2, gridSize * cellSize + cellSize / 2);
                }
            }
            if (moveCount % 10 === 9) {
                for (let col = 0; col < gridSize; col++) {
                    const lineBlock = nextLine[col];
                    const lineColor = Array.isArray(lineBlock) ? lineBlock[0] : lineBlock;
                    if (images[lineColor] && images[lineColor].complete) {
                        ctx.drawImage(images[lineColor], col * cellSize + 40 + 2, (gridSize + 1) * cellSize + 2, cellSize - 4, cellSize - 4);
                        if (Array.isArray(lineBlock) && lineBlock[0] === priksColor) {
                            ctx.fillStyle = "white";
                            ctx.font = "16px Arial";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(lineBlock[1], col * cellSize + 40 + cellSize / 2, (gridSize + 1) * cellSize + cellSize / 2);
                        }
                    }
                }
            }
            movingBlocks.forEach(({ x, y, color }) => {
                const moveColor = Array.isArray(color) ? color[0] : color;
                if (images[moveColor] && images[moveColor].complete) {
                    ctx.drawImage(images[moveColor], x + 2, y + 2, cellSize - 4, cellSize - 4);
                    if (Array.isArray(color) && color[0] === priksColor) {
                        ctx.fillStyle = "white";
                        ctx.font = "16px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(color[1], x + cellSize / 2, y + cellSize / 2);
                    }
                }
            });
            const nextNextColor = Array.isArray(nextNextBlock) ? nextNextBlock[0] : nextNextBlock;
            if (images[nextNextColor] && images[nextNextColor].complete) {
                ctx.drawImage(images[nextNextColor], 2, gridSize * cellSize + 2, 36, 36);
                if (Array.isArray(nextNextBlock) && nextNextBlock[0] === priksColor) {
                    ctx.fillStyle = "white";
                    ctx.font = "16px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(nextNextBlock[1], 2 + 18, gridSize * cellSize + 20);
                }
            }
        }

        // Animation pour un Blox ou une bombe jouée
        async function animateBlock(col, startY, endRow, isBomb = false) {
            const startRow = gridSize;
            const endY = endRow * cellSize;
            const duration = 100;
            const steps = 10;
            const stepDuration = duration / steps;
            const stepDistance = (startY - endY) / steps;

            let currentY = startY;
            const color = isBomb ? bombColor : nextBlock;
            for (let i = 0; i <= steps; i++) {
                drawGrid([{ x: col * cellSize + 40, y: currentY, color }]);
                currentY -= stepDistance;
                await new Promise(resolve => setTimeout(resolve, stepDuration));
            }
        }

        // Animation pour la gravité inversée
        async function animateGravity(movingBlocks) {
            const duration = 100;
            const steps = 10;
            const stepDuration = duration / steps;
            const animatedBlocks = movingBlocks.map(({ startRow, endRow, col, color }) => ({
                x: col * cellSize + 40,
                y: startRow * cellSize,
                targetY: endRow * cellSize,
                color,
                stepDistance: (startRow * cellSize - endRow * cellSize) / steps
            }));

            for (let i = 0; i <= steps; i++) {
                animatedBlocks.forEach(block => {
                    block.y -= block.stepDistance;
                });
                drawGrid(animatedBlocks);
                await new Promise(resolve => setTimeout(resolve, stepDuration));
            }
        }

        // Nouvelle fonction pour l’effet d’explosion de la bombe
         async function drawExplosionParticles(x, y) {
    const pixelSize = 2;
    const colors = ["#FF0000", "#FF4500", "#FFFF00", "#FFA500"];
    const explosionArea = 3 * cellSize;
    const baseX = x - explosionArea / 2;
    const baseY = y - explosionArea / 2;
    const particleCount = 50; // Par exemple, plus de confettis
    const duration = 450;
    const steps = 15;
    const stepDuration = duration / steps;
    const fallDistance = 20; // Distance de chute en pixels (ajustable)

    const particles = [];
    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: baseX + Math.random() * explosionArea,
            y: baseY + Math.random() * explosionArea,
            vy: fallDistance / steps, // Vitesse pour tomber de fallDistance en steps étapes
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }

    for (let frame = 0; frame < steps; frame++) {
        particles.forEach(p => {
            if (frame % 2 === 0) {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, pixelSize, pixelSize);
            }
            p.y += p.vy; // Faire descendre à chaque frame
        });
        await new Promise(resolve => setTimeout(resolve, stepDuration));
    }
}
        

        // Ajouter un Blox ou une bombe dans une colonne avec animation et particules pour la bombe
      async function addBlock(col) {
    let row = gridSize - 1;
    while (row >= 0 && !grid[row][col]) row--;
    row++;
    if (row >= gridSize) {
        endGame();
        return;
    }
    if (isBombSelected) {
        await animateBlock(col, gridSize * cellSize, row, true);
        let toRemove = [];
        for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
            for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
                if (grid[r][c]) {
                    toRemove.push([r, c]);
                }
            }
        }
        if (toRemove.length > 0) {
            const bombX = col * cellSize + 40 + cellSize / 2; // Centre exact de la bombe
            const bombY = row * cellSize + cellSize / 2;
            await blinkBlocks(toRemove, null, true, bombX, bombY); // Confettis et clignotement
            document.getElementById("bombSound").play();
        }
        for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
            for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
                grid[r][c] = null;
            }
        }
        bombCount--;
        isBombSelected = false;
        await animateGravity(calculateGravityMoves());
        await checkChains();
    } else {
        await animateBlock(col, gridSize * cellSize, row); // Animation du Blox
        grid[row][col] = nextBlock; // Placer le Blox dans la grille
        document.getElementById("placeSound").play();
        moveCount++;
        nextBlock = nextNextBlock;
        nextNextBlock = getNewBlock();
        await checkChains(); // Vérifier les chaînes
        if (moveCount % 10 === 0 && moveCount > 0) {
            addRandomLine();
            nextLine = getNewLine();
        }
    }
    drawGrid(); // Toujours redessiner à la fin
    updateUI(); // Mettre à jour l’UI
}
        // Ajouter la ligne complète avec 1 Priks
        function addRandomLine() {
            for (let col = 0; col < gridSize; col++) {
                let row = gridSize - 1;
                while (row >= 0 && !grid[row][col]) row--;
                row++;
                if (row >= gridSize) {
                    endGame();
                    return;
                }
                grid[row][col] = nextLine[col];
            }
            drawGrid();
            checkChains();
        }
        // ajout fonction score popup
        async function animateScorePopup(x, y, points) {
    const duration = 400; // 200ms au total
    const steps = 10; // 10 étapes pour une animation fluide
    const stepDuration = duration / steps;
    let size = 10; // Taille initiale
    const maxSize = 40; // Taille maximale

    for (let i = 0; i <= steps; i++) {
        ctx.save(); // Sauvegarder l’état du canvas
        ctx.fillStyle = "rgba(255, 215, 0, " + (1 - i / steps) + ")"; // Or avec fondu
        ctx.font = `${size}px gameboy`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`+${points}`, x, y);
        ctx.restore(); // Restaurer pour ne pas interférer avec le reste
        size = 10 + (maxSize - 10) * (i / steps); // Grandit de 10 à 20
        await new Promise(resolve => setTimeout(resolve, stepDuration));
    }
}
        // Faire clignoter les Blox avant suppression

       async function blinkBlocks(blocks, points = null, isBomb = false, bombX = null, bombY = null) {
    const blinkCount = 3;
    const blinkDuration = 150;

    let avgX = 0, avgY = 0;
    blocks.forEach(([row, col]) => {
        avgX += col * cellSize + 40 + cellSize / 2;
        avgY += row * cellSize + cellSize / 2;
    });
    avgX /= blocks.length;
    avgY /= blocks.length;

    let particlePromise = null;
    if (isBomb && bombX && bombY) {
        console.log("bombX:", bombX, "bombY:", bombY);
        particlePromise = drawExplosionParticles(bombX, bombY);
    }

    for (let i = 0; i < blinkCount; i++) {
        blocks.forEach(([row, col]) => {
            ctx.clearRect(col * cellSize + 40 + 2, row * cellSize + 2, cellSize - 4, cellSize - 4);
            ctx.strokeRect(col * cellSize + 40, row * cellSize, cellSize, cellSize);
        });
        if (points && i === 0) {
            animateScorePopup(avgX, avgY, points);
        }
        await new Promise(resolve => setTimeout(resolve, blinkDuration));
        drawGrid(); // Redessiner la grille à chaque étape
        await new Promise(resolve => setTimeout(resolve, blinkDuration));
    }

    if (particlePromise) {
        await particlePromise; // Attendre les confettis
    }
}
        // Vérifier et supprimer les chaînes de 5 ou plus en cascade, avec mise à jour des Priks
        async function checkChains() {
    let chainsRemoved;
    let isGravityChain = false;
    do {
        chainsRemoved = false;
        let visited = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
        let toRemove = [];

        function dfs(row, col, color, group) {
            if (row < 0 || row >= gridSize || col < 0 || col >= gridSize || visited[row][col] || (Array.isArray(grid[row][col]) ? grid[row][col][0] : grid[row][col]) !== color) {
                return;
            }
            visited[row][col] = true;
            group.push([row, col]);
            dfs(row - 1, col, color, group);
            dfs(row + 1, col, color, group);
            dfs(row, col - 1, color, group);
            dfs(row, col + 1, color, group);
            dfs(row - 1, col - 1, color, group);
            dfs(row - 1, col + 1, color, group);
            dfs(row + 1, col - 1, color, group);
            dfs(row + 1, col + 1, color, group);
        }

        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                if (grid[row][col] && !visited[row][col] && !Array.isArray(grid[row][col])) {
                    let group = [];
                    const color = grid[row][col];
                    dfs(row, col, color, group);
                    if (group.length >= 5) {
                        toRemove = toRemove.concat(group);
                        let points = isGravityChain ? 10 : (group.length > 5 ? 10 : 5);
                        score += points; // Ajouter les points ici
                        await blinkBlocks(group, points); // Appeler pour chaque groupe séparément
                        document.getElementById("chainSound").play();
                    }
                }
            }
        }

        if (toRemove.length > 0) {
            chainsRemoved = true;
            let priksAffected = new Set();
            let priksToRemove = [];
            toRemove.forEach(([row, col]) => {
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];
                directions.forEach(([dr, dc]) => {
                    const r = row + dr;
                    const c = col + dc;
                    if (r >= 0 && r < gridSize && c >= 0 && c < gridSize && grid[r][c] && Array.isArray(grid[r][c]) && grid[r][c][0] === priksColor) {
                        const key = `${r},${c}`;
                        if (!priksAffected.has(key)) {
                            priksAffected.add(key);
                            grid[r][c][1]--;
                            if (grid[r][c][1] <= 0) {
                                priksToRemove.push([r, c]);
                            }
                        }
                    }
                });
            });

            toRemove.forEach(([row, col]) => {
                grid[row][col] = null;
            });

            if (priksToRemove.length > 0) {
                await blinkBlocks(priksToRemove); // Pas de points pour les Priks
                priksToRemove.forEach(([row, col]) => {
                    grid[row][col] = null;
                });
            }

            chainCount++;
            if (chainCount % 10 === 0) bombCount++;
            isGravityChain = true;
            await animateGravity(calculateGravityMoves());
            drawGrid();
        } else {
            isGravityChain = false;
        }
    } while (chainsRemoved);
}
        

        // Calculer les mouvements de gravité pour l’animation
        function calculateGravityMoves() {
            let moves = [];
            for (let col = 0; col < gridSize; col++) {
                let newCol = [];
                for (let row = 0; row < gridSize; row++) {
                    if (grid[row][col]) newCol.push({ row, color: grid[row][col] });
                }
                for (let i = 0; i < newCol.length; i++) {
                    let startRow = newCol[i].row;
                    let endRow = i;
                    if (startRow !== endRow) {
                        moves.push({ startRow, endRow, col, color: newCol[i].color });
                    }
                }
                for (let row = 0; row < gridSize; row++) {
                    grid[row][col] = (row < newCol.length) ? newCol[row].color : null;
                }
            }
            return moves;
        }

        // Mettre à jour l'interface
        function updateUI() {
    document.getElementById("bombCount").textContent = bombCount;
    document.getElementById("score").textContent = score;
    const chainsToNextBomb = 10 - (chainCount % 10);
    document.getElementById("chainsRemaining").textContent = `Chaînes restantes : ${chainsToNextBomb}`;

    // Mise à jour de la barre de progression
    const progress = (moveCount % 10) * 10; // 0% à 90% (10 étapes)
    const progressBar = document.getElementById("progressBar");
    progressBar.style.width = `${progress}%`;
    // Changement de couleur selon la progression
    if (moveCount % 10 >= 8) {
        progressBar.style.backgroundColor = "#f44336"; // Rouge quand proche de 10
    } else if (moveCount % 10 >= 5) {
        progressBar.style.backgroundColor = "#ff9800"; // Orange au milieu
    } else {
        progressBar.style.backgroundColor = "#4caf50"; // Vert au début
    }
}

        // Fin du jeu avec gestion des hiscores
        function endGame() {
            const highScores = loadHighScores();
            if (score > highScores[9][1]) {
                addHighScore(score);
            }
            alert("Jeu terminé ! Score final : " + score);
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            bombCount = 1;
            chainCount = 0;
            score = 0;
            moveCount = 0;
            nextBlock = getNewBlock();
            nextNextBlock = getNewBlock();
            nextLine = getNewLine();
            isBombSelected = false;
            blockPosition = 0;
            drawGrid();
            updateUI();
        }

        // Gestion des touches du clavier (optionnel sur mobile)
        document.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "ArrowLeft":
                    if (blockPosition > 0) blockPosition--;
                    drawGrid();
                    break;
                case "ArrowRight":
                    if (blockPosition < gridSize - 1) blockPosition++;
                    drawGrid();
                    break;
                case " ":
                    event.preventDefault();
                    addBlock(blockPosition);
                    break;
                case "b":
                case "B":
                    if (bombCount > 0 && !isBombSelected) {
                        isBombSelected = true;
                        drawGrid();
                    }
                    break;
            }
        });

        // Gestion des clics/touch sur le canvas (colonnes)
        canvas.addEventListener("click", (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            if (y < gridSize * cellSize) {
                const col = Math.floor((x - 40) / cellSize); // Décalage de 40px à gauche
                if (col >= 0 && col < gridSize) {
                    blockPosition = col; // Déplacer le curseur
                    addBlock(col); // Placer le blox ou la bombe
                }
            }
        });

        // Gestion du clic sur l’icône de bombe
        document.getElementById("bombIcon").addEventListener("click", () => {
            if (bombCount > 0 && !isBombSelected) {
                isBombSelected = true;
                drawGrid();
            }
        });

        // Attendre que toutes les images soient chargées avant de démarrer
        let imagesLoaded = 0;
        const totalImages = colors.length + 2;
        function checkImagesLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                updateHighScoresDisplay();
                drawGrid();
                updateUI();
            }
        }

        Object.values(images).forEach(img => {
            img.onload = checkImagesLoaded;
            img.onerror = () => {
                console.error(`Erreur de chargement de l'image : ${img.src}`);
                checkImagesLoaded();
            };
        });
    </script>
</body>
</html>
