<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Priks</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        #gameContainer {
            text-align: center;
            font-family: Arial, sans-serif;
            position: relative;
        }
        #info {
            margin-top: 10px;
        }
        #rules {
            font-size: 0.9em;
            margin-top: 5px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #underGrid {
            display: flex;
            justify-content: space-between;
            width: 320px;
            margin: 5px auto 0;
        }
        #scoreDisplay {
            font-size: 1.5em;
        }
        #bombDisplay {
            display: flex;
            align-items: center;
        }
        #bombDisplay img {
            width: 36px;
            height: 36px;
            margin-right: 5px;
        }
        #bombCount {
            font-size: 1.5em;
        }
        #highScores {
            position: absolute;
            right: calc(50% - 250px); /* À droite du canvas (320/2 + marge) */
            top: 0;
            width: 150px;
            text-align: left;
            font-size: 0.9em;
        }
        #highScores h3 {
            margin: 0 0 5px 0;
        }
        #highScores ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="360" height="400"></canvas>
        <div id="highScores">
            <h3>Meilleurs Scores</h3>
            <ul id="highScoreList"></ul>
        </div>
        <div id="info">
            <p>Utilisez ← et → pour déplacer, Espace pour placer, B pour sélectionner une bombe</p>
            <p id="rules">Le but de Priks est de faire le plus gros score en faisant des chaînes de 5 blox de même couleur. La difficulté ? Régulièrement, des blox gris arrivent (des Priks) qui ne peuvent pas être cassés. Et tous les 10 tours, une floppée de blox vient mettre le bazar. Heureusement, vous disposez de bombes (1 au début, puis 1 supplémentaire toutes les 5 chaînes) qui cassent tout ce qu'elles touchent - y compris les Priks ! À vous de jouer !</p>
        </div>
        <div id="underGrid">
            <div id="scoreDisplay">Score : <span id="score">0</span></div>
            <div id="bombDisplay">
                <img src="bomb.png" alt="Bombes" id="bombIcon">
                <span id="bombCount">1</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const gridSize = 8;
        const cellSize = 320 / gridSize;
        const previewHeight = cellSize * 2;
        let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
        let bombCount = 1;
        let chainCount = 0;
        let score = 0;
        let moveCount = 0;
        let nextBlock = null;
        let nextNextBlock = null;
        let blockPosition = 0;
        let nextLine = null;
        let isBombSelected = false;

        const colors = ["red", "blue", "green", "yellow", "purple", "orange"];
        const priksColor = "gray";
        const bombColor = "bomb";

        // Charger les images
        const images = {};
        colors.forEach(color => {
            images[color] = new Image();
            images[color].src = `${color}.png`;
        });
        images[priksColor] = new Image();
        images[priksColor].src = "priks.png";
        images[bombColor] = new Image();
        images[bombColor].src = "bomb.png";

        // Générer un nouveau Blox
        function getNewBlock() {
            if (Math.random() < 0.1) return priksColor;
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Générer une nouvelle ligne de 8 Blox
        function getNewLine() {
            let newLine = Array(gridSize);
            for (let i = 0; i < gridSize; i++) {
                newLine[i] = colors[Math.floor(Math.random() * colors.length)];
            }
            let priksCol = Math.floor(Math.random() * gridSize);
            newLine[priksCol] = priksColor;
            return newLine;
        }

        if (!nextBlock) nextBlock = getNewBlock();
        if (!nextNextBlock) nextNextBlock = getNewBlock();
        if (!nextLine) nextLine = getNewLine();

        // Charger et afficher les hiscores
        function loadHighScores() {
            const highScores = JSON.parse(localStorage.getItem("priksHighScores")) || [];
            return highScores.length ? highScores : [["AAAAA", 0], ["BBBBB", 0], ["CCCCC", 0], ["DDDDD", 0], ["EEEEE", 0], ["FFFFF", 0], ["GGGGG", 0], ["HHHHH", 0], ["IIIII", 0], ["JJJJJ", 0]];
        }

        function saveHighScores(highScores) {
            localStorage.setItem("priksHighScores", JSON.stringify(highScores));
        }

        function updateHighScoresDisplay() {
            const highScores = loadHighScores();
            const list = document.getElementById("highScoreList");
            list.innerHTML = "";
            highScores.forEach(([name, score]) => {
                const li = document.createElement("li");
                li.textContent = `${name} : ${score}`;
                list.appendChild(li);
            });
        }

        function addHighScore(score) {
            let highScores = loadHighScores();
            let name = prompt("Nouveau highscore ! Entrez vos initiales (5 lettres max) :", "AAAAA");
            if (name) {
                name = name.slice(0, 5).padEnd(5, " ").toUpperCase(); // Limite à 5 lettres, complète avec espaces
                highScores.push([name, score]);
                highScores.sort((a, b) => b[1] - a[1]); // Tri décroissant par score
                highScores = highScores.slice(0, 10); // Garder les 10 premiers
                saveHighScores(highScores);
                updateHighScoresDisplay();
            }
        }

        // Dessiner la grille avec images
        function drawGrid(movingBlocks = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    ctx.strokeRect(col * cellSize + 40, row * cellSize, cellSize, cellSize);
                    if (grid[row][col] && images[grid[row][col]]) {
                        ctx.drawImage(images[grid[row][col]], col * cellSize + 40 + 2, row * cellSize + 2, cellSize - 4, cellSize - 4);
                    }
                }
            }
            ctx.strokeRect(40, gridSize * cellSize, 320, previewHeight);
            const previewImage = isBombSelected ? images[bombColor] : images[nextBlock];
            if (previewImage && previewImage.complete) {
                ctx.drawImage(previewImage, blockPosition * cellSize + 40 + 2, gridSize * cellSize + 2, cellSize - 4, cellSize - 4);
            }
            if (moveCount % 10 === 9) {
                for (let col = 0; col < gridSize; col++) {
                    if (images[nextLine[col]] && images[nextLine[col]].complete) {
                        ctx.drawImage(images[nextLine[col]], col * cellSize + 40 + 2, (gridSize + 1) * cellSize + 2, cellSize - 4, cellSize - 4);
                    }
                }
            }
            movingBlocks.forEach(({ x, y, color }) => {
                if (images[color] && images[color].complete) {
                    ctx.drawImage(images[color], x + 2, y + 2, cellSize - 4, cellSize - 4);
                }
            });
            if (images[nextNextBlock] && images[nextNextBlock].complete) {
                ctx.drawImage(images[nextNextBlock], 2, gridSize * cellSize + 2, 36, 36);
            }
        }

        // Animation pour un Blox ou une bombe jouée
        async function animateBlock(col, startY, endRow, isBomb = false) {
            const startRow = gridSize;
            const endY = endRow * cellSize;
            const duration = 100;
            const steps = 10;
            const stepDuration = duration / steps;
            const stepDistance = (startY - endY) / steps;

            let currentY = startY;
            const color = isBomb ? bombColor : nextBlock;
            for (let i = 0; i <= steps; i++) {
                drawGrid([{ x: col * cellSize + 40, y: currentY, color }]);
                currentY -= stepDistance;
                await new Promise(resolve => setTimeout(resolve, stepDuration));
            }
        }

        // Animation pour la gravité inversée
        async function animateGravity(movingBlocks) {
            const duration = 100;
            const steps = 10;
            const stepDuration = duration / steps;
            const animatedBlocks = movingBlocks.map(({ startRow, endRow, col, color }) => ({
                x: col * cellSize + 40,
                y: startRow * cellSize,
                targetY: endRow * cellSize,
                color,
                stepDistance: (startRow * cellSize - endRow * cellSize) / steps
            }));

            for (let i = 0; i <= steps; i++) {
                animatedBlocks.forEach(block => {
                    block.y -= block.stepDistance;
                });
                drawGrid(animatedBlocks);
                await new Promise(resolve => setTimeout(resolve, stepDuration));
            }
        }

        // Ajouter un Blox ou une bombe dans une colonne avec animation
        async function addBlock(col) {
            let row = gridSize - 1;
            while (row >= 0 && !grid[row][col]) row--;
            row++;
            if (row >= gridSize) {
                endGame();
                return;
            }
            if (isBombSelected) {
                await animateBlock(col, gridSize * cellSize, row, true);
                let toRemove = [];
                for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
                        if (grid[r][c]) {
                            toRemove.push([r, c]);
                        }
                    }
                }
                if (toRemove.length > 0) {
                    await blinkBlocks(toRemove);
                }
                for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
                        grid[r][c] = null;
                    }
                }
                bombCount--;
                isBombSelected = false;
                await animateGravity(calculateGravityMoves());
                await checkChains();
            } else {
                await animateBlock(col, gridSize * cellSize, row);
                grid[row][col] = nextBlock;
                moveCount++;
                nextBlock = nextNextBlock;
                nextNextBlock = getNewBlock();
                await checkChains();
                if (moveCount % 10 === 0 && moveCount > 0) {
                    addRandomLine();
                    nextLine = getNewLine();
                }
            }
            drawGrid();
            updateUI();
        }

        // Ajouter la ligne complète avec 1 Priks
        function addRandomLine() {
            for (let col = 0; col < gridSize; col++) {
                let row = gridSize - 1;
                while (row >= 0 && !grid[row][col]) row--;
                row++;
                if (row >= gridSize) {
                    endGame();
                    return;
                }
                grid[row][col] = nextLine[col];
            }
            drawGrid();
            checkChains();
        }

        // Faire clignoter les Blox avant suppression
        async function blinkBlocks(blocks) {
            const blinkCount = 3;
            const blinkDuration = 150;

            for (let i = 0; i < blinkCount; i++) {
                blocks.forEach(([row, col]) => {
                    ctx.clearRect(col * cellSize + 40 + 2, row * cellSize + 2, cellSize - 4, cellSize - 4);
                    ctx.strokeRect(col * cellSize + 40, row * cellSize, cellSize, cellSize);
                });
                await new Promise(resolve => setTimeout(resolve, blinkDuration));
                drawGrid();
                await new Promise(resolve => setTimeout(resolve, blinkDuration));
            }
        }

        // Vérifier et supprimer les chaînes de 5 ou plus en cascade
        async function checkChains() {
            let chainsRemoved;
            let isGravityChain = false;
            do {
                chainsRemoved = false;
                let visited = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
                let toRemove = [];

                function dfs(row, col, color, group) {
                    if (row < 0 || row >= gridSize || col < 0 || col >= gridSize || visited[row][col] || grid[row][col] !== color) {
                        return;
                    }
                    visited[row][col] = true;
                    group.push([row, col]);
                    dfs(row - 1, col, color, group);
                    dfs(row + 1, col, color, group);
                    dfs(row, col - 1, color, group);
                    dfs(row, col + 1, color, group);
                    dfs(row - 1, col - 1, color, group);
                    dfs(row - 1, col + 1, color, group);
                    dfs(row + 1, col - 1, color, group);
                    dfs(row + 1, col + 1, color, group);
                }

                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (grid[row][col] && grid[row][col] !== priksColor && !visited[row][col]) {
                            let group = [];
                            dfs(row, col, grid[row][col], group);
                            if (group.length >= 5) {
                                toRemove = toRemove.concat(group);
                                if (isGravityChain) {
                                    score += 10;
                                } else if (group.length > 5) {
                                    score += 10;
                                } else {
                                    score += 5;
                                }
                            }
                        }
                    }
                }

                if (toRemove.length > 0) {
                    chainsRemoved = true;
                    await blinkBlocks(toRemove);
                    toRemove.forEach(([row, col]) => {
                        grid[row][col] = null;
                    });
                    chainCount++;
                    if (chainCount % 5 === 0) bombCount++;
                    isGravityChain = true;
                    await animateGravity(calculateGravityMoves());
                    drawGrid();
                } else {
                    isGravityChain = false;
                }
            } while (chainsRemoved);
        }

        // Calculer les mouvements de gravité pour l’animation
        function calculateGravityMoves() {
            let moves = [];
            for (let col = 0; col < gridSize; col++) {
                let newCol = [];
                for (let row = 0; row < gridSize; row++) {
                    if (grid[row][col]) newCol.push({ row, color: grid[row][col] });
                }
                for (let i = 0; i < newCol.length; i++) {
                    let startRow = newCol[i].row;
                    let endRow = i;
                    if (startRow !== endRow) {
                        moves.push({ startRow, endRow, col, color: newCol[i].color });
                    }
                }
                for (let row = 0; row < gridSize; row++) {
                    grid[row][col] = (row < newCol.length) ? newCol[row].color : null;
                }
            }
            return moves;
        }

        // Mettre à jour l'interface
        function updateUI() {
            document.getElementById("bombCount").textContent = bombCount;
            document.getElementById("score").textContent = score;
        }

        // Fin du jeu avec gestion des hiscores
        function endGame() {
            const highScores = loadHighScores();
            if (score > highScores[9][1]) { // Si le score dépasse le 10e
                addHighScore(score);
            }
            alert("Jeu terminé ! Score final : " + score);
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            bombCount = 1;
            chainCount = 0;
            score = 0;
            moveCount = 0;
            nextBlock = getNewBlock();
            nextNextBlock = getNewBlock();
            nextLine = getNewLine();
            isBombSelected = false;
            blockPosition = 0;
            drawGrid();
            updateUI();
        }

        // Gestion des touches du clavier
        document.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "ArrowLeft":
                    if (blockPosition > 0) blockPosition--;
                    drawGrid();
                    break;
                case "ArrowRight":
                    if (blockPosition < gridSize - 1) blockPosition++;
                    drawGrid();
                    break;
                case " ":
                    event.preventDefault();
                    addBlock(blockPosition);
                    break;
                case "b":
                case "B":
                    if (bombCount > 0 && !isBombSelected) {
                        isBombSelected = true;
                        drawGrid();
                    }
                    break;
            }
        });

        // Attendre que toutes les images soient chargées avant de démarrer
        let imagesLoaded = 0;
        const totalImages = colors.length + 2;
        function checkImagesLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                updateHighScoresDisplay(); // Afficher les hiscores au démarrage
                drawGrid();
                updateUI();
            }
        }

        Object.values(images).forEach(img => {
            img.onload = checkImagesLoaded;
            img.onerror = () => {
                console.error(`Erreur de chargement de l'image : ${img.src}`);
                checkImagesLoaded();
            };
        });
    </script>
</body>
</html>
